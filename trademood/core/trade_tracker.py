import sqlite3
from datetime import datetime, timezone
import pandas as pd
import yfinance as yf
import exchange_calendars as xcals

class TradeTracker:
    """
    A class used to track open and closed trades, including the calculation of Profit & Loss (P&L).

    This component is designed to manage the lifecycle of simulated or actual
    trades generated by the trading signals. It records trade entries, exits,
    and computes the financial performance (P&L) of each trade.

    Attributes
    ----------
    db_handler : DatabaseHandler
        An instance of the `DatabaseHandler` for persisting trade data (open trades,
        closed trades, P&L records).
    error_handler : ErrorHandler
        An instance of the `ErrorHandler` for logging any errors encountered
        during trade tracking or P&L calculation.

    Methods
    -------
    record_open_trade(trading_signal, entry_price)
        Records a new open trade based on a trading signal and entry price.
    record_closed_trade(trade_id, exit_price)
        Records the closure of an existing trade, calculating the P&L.
    get_open_trades()
        Retrieves a list of all currently open trades.
    get_closed_trades()
        Retrieves a list of all historically closed trades with their P&L.
    calculate_pnl(entry_price, exit_price, trade_type)
        Calculates the Profit & Loss for a single trade.
    """
    
    def __init__(self, db_handler, error_handler):
        self.db_handler = db_handler
        self.error_handler = error_handler
        self._init_trade_tables()
        
    def _init_trade_tables(self):
        """Initialize trade tracking tables."""
        with sqlite3.connect(self.db_handler.db_path) as conn:
            cursor = conn.cursor()
            
            # Create trades table
            cursor.execute("""
            CREATE TABLE IF NOT EXISTS trades (
                trade_id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                entry_time DATETIME NOT NULL,
                exit_time DATETIME,
                entry_price REAL NOT NULL,
                exit_price REAL,
                quantity REAL NOT NULL,
                direction TEXT NOT NULL,
                status TEXT NOT NULL,
                pnl REAL,
                pnl_pct REAL,
                stop_loss REAL,
                take_profit REAL,
                sentiment_score REAL,
                signal_confidence REAL,
                strategy TEXT
            )
            """)
            
            # Create price data table
            cursor.execute("""
            CREATE TABLE IF NOT EXISTS price_data (
                timestamp DATETIME PRIMARY KEY,
                symbol TEXT NOT NULL,
                open REAL NOT NULL,
                high REAL NOT NULL,
                low REAL NOT NULL,
                close REAL NOT NULL,
                volume REAL NOT NULL,
                interval TEXT NOT NULL
            )
            """)
            
            conn.commit()

    def record_trade(self, symbol: str, entry_price: float, quantity: float, 
                    direction: str, sentiment_score: float, confidence: float,
                    stop_loss: float = None, take_profit: float = None,
                    strategy: str = "Sentiment"):
        """Record a new trade entry."""
        with sqlite3.connect(self.db_handler.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute("""
            INSERT INTO trades (
                symbol, entry_time, entry_price, quantity, direction,
                status, sentiment_score, signal_confidence, stop_loss,
                take_profit, strategy
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                symbol, datetime.now(), entry_price, quantity, direction,
                "OPEN", sentiment_score, confidence, stop_loss,
                take_profit, strategy
            ))
            conn.commit()
            return cursor.lastrowid

    def close_trade(self, trade_id: int, exit_price: float) -> None:
        """Close an open trade and calculate P&L."""
        try:
            with sqlite3.connect(self.db_handler.db_path) as conn:
                trade = pd.read_sql(
                    f"SELECT * FROM trades WHERE trade_id = {trade_id} AND status = 'OPEN'",
                    conn
                )
                if trade.empty:
                    self.error_handler.log_warning(f"Trade {trade_id} not found or already closed")
                    return
                
                entry_price = trade.iloc[0]['entry_price']
                quantity = trade.iloc[0]['quantity']
                direction = trade.iloc[0]['direction']
                
                if direction == "LONG":
                    pnl = (exit_price - entry_price) * quantity
                else:  # SHORT
                    pnl = (entry_price - exit_price) * quantity
                    
                pnl_pct = (pnl / (entry_price * quantity)) * 100 if entry_price * quantity != 0 else 0
                
                query = """
                UPDATE trades 
                SET status = 'CLOSED', exit_price = ?, exit_time = ?, 
                    pnl = ?, pnl_pct = ?
                WHERE trade_id = ?
                """
                conn.execute(query, (
                    exit_price,
                    datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S'),
                    pnl,
                    pnl_pct,
                    trade_id
                ))
                conn.commit()
                
                self.error_handler.log_info(f"Closed trade {trade_id} at ${exit_price:,.2f}, P&L: ${pnl:,.2f} ({pnl_pct:.2f}%)")
                
        except Exception as e:
            self.error_handler.log_error(e, f"closing trade {trade_id}")
            raise
    
    def update_price_data(self, symbol: str, interval: str = "5m"):
        """Fetch and store latest price data."""
        try:
            # Check if COMEX is open
            comex = xcals.get_calendar("CME")
            now = pd.Timestamp.now(tz="America/New_York")
            if not comex.is_session(now.date()) or not comex.is_open_at_time(now):
                self.error_handler.log_warning(f"COMEX market is closed for {symbol}, using longer period")
                period = "1mo" 
            else:
                period = "5d"
            
            # Validate interval
            valid_intervals = ["1m", "2m", "5m", "15m", "30m", "60m", "90m", "1h", "1d", "5d", "1wk", "1mo", "3mo"]
            if interval not in valid_intervals:
                self.error_handler.log_warning(f"Invalid interval {interval} for {symbol}, defaulting to 5m")
                interval = "5m"
            
            self.error_handler.log_info(f"Fetching price data for {symbol} with interval {interval}")
            data = yf.download(
                symbol,
                period=period,
                interval=interval,
                prepost=True,
                auto_adjust=False
            ).reset_index()
            
            if data.empty:
                self.error_handler.log_warning(f"No price data fetched for {symbol} with interval {interval}")
                return
            
            # Handle MultiIndex columns
            if isinstance(data.columns, pd.MultiIndex):
                data.columns = [col[0] if col[1] == '' else col[0] for col in data.columns]
            
            # Rename columns to match database schema
            data = data.rename(columns={
                'Datetime': 'timestamp',
                'Date': 'timestamp',
                'Open': 'open',
                'High': 'high',
                'Low': 'low',
                'Close': 'close',
                'Volume': 'volume'
            })
            
            # Select only the columns that match the database schema
            db_columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
            data = data[[col for col in db_columns if col in data.columns]]
            data['symbol'] = symbol
            data['interval'] = interval
            data['timestamp'] = pd.to_datetime(data['timestamp']).dt.strftime('%Y-%m-%d %H:%M:%S')
            
            with sqlite3.connect(self.db_handler.db_path) as conn:
                existing_timestamps = pd.read_sql(
                    f"SELECT timestamp FROM price_data WHERE symbol = '{symbol}' AND interval = '{interval}'",
                    conn
                )['timestamp'].tolist()
                
                data = data[~data['timestamp'].isin(existing_timestamps)]
                
                if not data.empty:
                    chunk_size = 100
                    for i in range(0, len(data), chunk_size):
                        chunk = data.iloc[i:i + chunk_size]
                        chunk.to_sql(
                            'price_data',
                            conn,
                            if_exists='append',
                            index=False,
                            method=None
                        )
                    self.error_handler.log_info(f"Updated price data for {symbol} ({len(data)} rows)")
                else:
                    self.error_handler.log_info(f"No new price data to insert for {symbol}")
                    
        except Exception as e:
            self.error_handler.log_error(e, f"updating price data for {symbol}")
                   
    def get_open_trades(self):
        """Get all open trades."""
        with sqlite3.connect(self.db_handler.db_path) as conn:
            return pd.read_sql(
                "SELECT * FROM trades WHERE status = 'OPEN' ORDER BY entry_time DESC",
                conn
            )

    def get_closed_trades(self, limit: int = 20):
        """Get recent closed trades."""
        with sqlite3.connect(self.db_handler.db_path) as conn:
            return pd.read_sql(
                f"SELECT * FROM trades WHERE status = 'CLOSED' ORDER BY exit_time DESC LIMIT {limit}",
                conn
            )

    def get_trade_history(self, symbol: str = None):
        """Get complete trade history."""
        query = "SELECT * FROM trades ORDER BY entry_time DESC"
        if symbol:
            query = f"SELECT * FROM trades WHERE symbol = '{symbol}' ORDER BY entry_time DESC"
            
        with sqlite3.connect(self.db_handler.db_path) as conn:
            return pd.read_sql(query, conn)
